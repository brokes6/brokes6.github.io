<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Room在项目中的使用 |
    
    Fuxinbo博客</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Fuxinbo博客" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-Room在项目中的使用" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  Room在项目中的使用
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/12/24/Room%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2020-12-24T07:56:00.000Z" itemprop="datePublished">2020-12-24</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>介绍JetPack中的Room</p>
<a id="more"></a>
<h1 id="Room在项目中的使用"><a href="#Room在项目中的使用" class="headerlink" title="Room在项目中的使用"></a>Room在项目中的使用</h1><blockquote>
<p>本篇已Java为主要语言</p>
</blockquote>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code class="java">implementation &quot;androidx.room:room-runtime:2.2.5&quot;
annotationProcessor  &quot;androidx.room:room-compiler:2.2.5&quot;</code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>接下来我就以保存历史为例,先介绍一下各个注释的意思</p>
<table>
<thead>
<tr>
<th>注释名称</th>
<th>意思</th>
</tr>
</thead>
<tbody><tr>
<td>@Entity</td>
<td>代表数据库中某个表的实体类。</td>
</tr>
<tr>
<td>@Ignore</td>
<td>代表无用的构造方法</td>
</tr>
<tr>
<td>@PrimaryKey()</td>
<td>代表主键的意思，是必须要有的</td>
</tr>
<tr>
<td>@Database</td>
<td>包含数据库持有者，并作为与应用持久关联数据的底层连接的主要访问点</td>
</tr>
</tbody></table>
<ol>
<li><p>创建 HistoryBean</p>
<pre><code class="java">@Entity
public class HistoryBean &#123;

    public HistoryBean() &#123;

    &#125;

    @Ignore
    public HistoryBean(int id, String name, String address, String state) &#123;
        this.EquipmentId = id;
        this.EquipmentName = name;
        this.EquipmentAddress = address;
        this.EquipmentState = state;
    &#125;

    @PrimaryKey()
    private int EquipmentId;
    private String EquipmentName;
    private String EquipmentAddress;
    private String EquipmentPersonnel;
    private String EquipmentState;

    public int getEquipmentId() &#123;
        return EquipmentId;
    &#125;

    public void setEquipmentId(int equipmentId) &#123;
        EquipmentId = equipmentId;
    &#125;

    public String getEquipmentName() &#123;
        return EquipmentName;
    &#125;

    public void setEquipmentName(String equipmentName) &#123;
        EquipmentName = equipmentName;
    &#125;

    public String getEquipmentAddress() &#123;
        return EquipmentAddress;
    &#125;

    public void setEquipmentAddress(String equipmentAddress) &#123;
        EquipmentAddress = equipmentAddress;
    &#125;

    public String getEquipmentPersonnel() &#123;
        return EquipmentPersonnel;
    &#125;

    public void setEquipmentPersonnel(String equipmentPersonnel) &#123;
        EquipmentPersonnel = equipmentPersonnel;
    &#125;

    public String getEquipmentState() &#123;
        return EquipmentState;
    &#125;

    public void setEquipmentState(String equipmentState) &#123;
        EquipmentState = equipmentState;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<ol start="2">
<li><p>创建一个数据库管理类 （AppDatabase）继承 RoomDatabase</p>
<pre><code class="java">@Database(entities = &#123;HistoryBean.class&#125;, version = 1)
public abstract class AppDatabase extends RoomDatabase &#123;

   public abstract HistoryDao historyDao();

&#125;</code></pre>
</li>
<li><p>然后在创建一个数据库操作接口 （HistoryDao）</p>
<pre><code class="java">@Dao
public interface HistoryDao &#123;
    /**
     * 插入数据
     *
     * @param historyBean
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void insertAll(HistoryBean historyBean);

    /**
     * 删除数据
     */
    @Query(&quot;DELETE FROM historybean&quot;)
    void deleteAll();

    /**
     * 更新数据（传入不一样的数据，将会自动将不一样的数据替换旧数据）
     *
     * @param historyBean
     */
    @Update
    void updateUsers(HistoryBean historyBean);

    /**
     * 查询数据
     *
     * @return
     */
    @Query(&quot;SELECT * FROM HistoryBean&quot;)
    LiveData&lt;List&lt;HistoryBean&gt;&gt; getAll();
&#125;</code></pre>
</li>
</ol>
<ol start="4">
<li><p>接下来就是在Activity/Fragment中使用，因为在主线程中是不允许进行数据库操作的，会阻塞线程，所以必须要在子线程中来操作数据库。下面的代码就是使用AsyncTask来进行子线程操作</p>
<p>那么下面将创建一个数据库操作类，用来方便进行数据库操作</p>
<pre><code class="java">public class DaoOperation &#123;
    private static AppDatabase db;
    private static DaoOperation instance;

    //这里将DaoOpertaion设置为单例模式，因为会在各种地方使用
    public static DaoOperation getDatabase(Context context) &#123;
        if (instance == null) &#123;
            synchronized (AppDatabase.class) &#123;
                if (instance == null) &#123;
                    db = MyApplication.getDatabase(context);
                    instance = new DaoOperation();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;

    //这里是对外开放接口
    public void insertHistory(HistoryBean historyBean) &#123;
        new insertHistory(historyBean).execute(historyBean);
    &#125;

    public void dellHistory() &#123;
        new dellHistory().execute();
    &#125;

    public void upHistory(HistoryBean historyBean) &#123;
        new upHistory(historyBean).execute(historyBean);
    &#125;

</code></pre>
</li>
</ol>
<pre><code>   //以下是内部实现过程
   /**
    * 插入历史
    */
   private static class insertHistory extends AsyncTask&lt;HistoryBean, Void, Void&gt; &#123;
       private final HistoryBean historyBean;

       public insertHistory(HistoryBean historyBean) &#123;
           this.historyBean = historyBean;
       &#125;

       @Override
       protected Void doInBackground(HistoryBean... historyBeans) &#123;
           db.historyDao().insertAll(historyBean);
           return null;
       &#125;
   &#125;

   /**
    * 删除全部历史
    */
   private static class dellHistory extends AsyncTask&lt;Void, Void, Void&gt; &#123;

       public dellHistory() &#123;
       &#125;

       @Override
       protected Void doInBackground(Void... voids) &#123;
           db.historyDao().deleteAll();
           return null;
       &#125;
   &#125;

   /**
    * 更改历史（基本用不上）
    */
   private static class upHistory extends AsyncTask&lt;HistoryBean, Void, Void&gt; &#123;
       private final HistoryBean historyBean;

       public upHistory(HistoryBean historyBean) &#123;
           this.historyBean = historyBean;

       &#125;

       @Override
       protected Void doInBackground(HistoryBean... historyBeans) &#123;
           db.historyDao().updateUsers(historyBean);
           return null;
       &#125;
   &#125;</code></pre>
<pre><code>
关于AsyncTast的使用，其他篇幅就已经讲过了，这里就并进行讲解了 [关于Android多线程操作](关于Android多线程操作.md)

5. 最后在Activty/Fragment中使用（展示经常使用的插入和删除）

`插入`

```java
DaoOperation.getDatabase(this).insertHistory(new HistoryBean(id,name, address,state));</code></pre>
<p>   <code>删除</code></p>
<pre><code class="java">DaoOperation.getDatabase(this).dellHistory();</code></pre>
<ol start="6">
<li><p>展示不一样的数据库查询（下面的代码HistoryModel是因为我当前项目使用的Mvvm的设计模式，我将所以数据操作都放在Model中了）</p>
<p>因为上面设置查询的结果为LiveData，也就是可观察</p>
<pre><code class="java">HistoryModel mHistoryModel = new ViewModelProvider(this).get(HistoryModel.class);
        mHistoryModel.getHistory(this).observe(this, new Observer&lt;List&lt;HistoryBean&gt;&gt;() &#123;
            @Override
            public void onChanged(List&lt;HistoryBean&gt; historyBeans) &#123;
                //这里我是将查询到的数据传入设配器中
                adapter.loadMore(historyBeans);
            &#125;
        &#125;);</code></pre>
<p>关于使用LiveData的好处有多，比如</p>
<ul>
<li>会观察当前引用类的生命周期，只会在生命周期内进行操作</li>
<li>不会造成内存泄漏</li>
<li>一旦数据发送变化，将立马通知</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/24/Room%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="cknjh7pea000higme7gtv4pj3" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sql/" rel="tag">Sql</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2020/12/24/WorkManager%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      WorkManager后台任务
      
    </div>
  </a>
  
  
  <a href="/2020/12/17/SmallestWidth-%E9%99%90%E5%AE%9A%E7%AC%A6/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">SmallestWidth 限定符</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Fuxinbo博客 &copy; 2021</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Fuxinbo博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>